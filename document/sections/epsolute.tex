\section{\epsolute{}: Efficiently Querying Databases While Providing Differential Privacy~\cite{epsolute}}

	\begin{frame}{Background: Differential Privacy and Sanitization}

		\begin{definition}[\alert{Differential Privacy}, adapted from~\cite{our-data-ourselves, differential-privacy-original}]
			\justify%

			A randomized algorithm \algo{A} is $(\epsilon, \delta)$-differentially private if for all $\database_1 \sim \database_2 \in \searchKeyDomain^\dataSize$, and for all subsets $\mathcal{O}$ of the output space of \algo{A},
			\[
				\probability{ \algo{A}{ \database_1 } \in \mathcal{O} } \leq \exp(\epsilon) \cdot \probability{ \algo{A}{ \database_2 } \in \mathcal{O} } + \delta \; .
			\]
		\end{definition}

		\pause%

		\begin{theorem}[\alert{Laplace Perturbation Algorithm (LPA)}, adapted Theorem 1 from~\cite{differential-privacy-original}]
			\justify%

			An algorithm \algo{A} that adds independently generated noise from a \textbf{zero-mean Laplace distribution} with scale $\lambda = \frac{\textsf{sensitivity of query}}{\epsilon}$ to each coordinate of a query result, satisfies $\epsilon$-differential privacy.
		\end{theorem}

		\pause%

		\begin{definition}[\alert{Differentially Private Sanitizer}, informal]
			\justify%

			An $(\epsilon, \delta, \alpha, \beta)$-differentially private sanitizer is a pair of algorithms $(\algo{A}, \algo{B})$ such that:
			\begin{itemize}
				\item $A$ is $(\epsilon, \delta)$-differentially private, and
				\item on input a dataset, \algo{A} outputs a data structure \serverDS{} such that with probability $1 - \beta$ for all queries, $\algo{B}{ \serverDS, \query }$ is within $\alpha$ of a real query result.
			\end{itemize}
		\end{definition}

	\end{frame}

	\begin{frame}{Background: Access pattern and ORAM}

		\justifying%

		\textbf{Access pattern} is a sequence of memory accesses \oramProgram{}, where each access consists of the memory \emph{location} $o$, read \oramRead{} or write \oramWrite{} \emph{operation} and the \emph{data} $d$ to be written.

		Oblivious RAM (ORAM) is a mechanism that hides the accesses pattern.
		More formally, \oram{} is a protocol between the client \client{} (who accesses) and the server \server{} (who stores), with a guarantee that the view of the server is indistinguishable for any two sequences of the same lengths.

		\begin{columns}[T]
			\column{0.475\textwidth}

				\[
					\begin{split}
						\abs{\oramProgram_1}					& = \abs{\oramProgram_2}							\\
						\textsc{View}_\server (\oramProgram_1)	& \cindist \textsc{View}_\server (\oramProgram_2)
					\end{split}
				\]

			\column{0.475\textwidth}

				\procedure[linenumbering]{\oram{} protocol}{
					\textbf{Client \client}											\>														\> \textbf{Server \server}	\\
					%
					\oramProgram{} = \left. (\oramRead, i, \bot) \right|_{i = 1}^5	\> 														\>							\\
					%
					\text{(client state)}											\> \sendmessageboth*[6em]{\algo{ORAM}{\oramProgram}}	\> \text{(server state)}	\\
					%
					\{ d_1, d_2, d_3, d_4, d_5 \}									\>														\>
				}

		\end{columns}

		\vspace*{1ex}

		For example: Square Root ORAM~\cite{oram-theory}, Hierarchical ORAM~\cite{oram-original}, Binary-Tree ORAM~\cite{binary-tree-oram}, Interleave Buffer Shuffle Square Root ORAM~\cite{shortest-path-oram}, TP-ORAM~\cite{tp-oram}, \textbf{Path-ORAM}~\cite{path-oram} and TaORAM~\cite{taostore}.
		\alert{ORAM incurs at least logarithmic overhead in the number of stored records.~\cite{oram-original}}

	\end{frame}

	\begin{frame}{Differentially Private Outsourced Database System}

		Model: \alert{persistent}, query type: \alert{point} and \alert{range}

		\begin{definition}[\alert{Computationally Differentially Private Outsourced Database System (CDP-ODB)}]
			\justify%

			We say that an outsourced database system \protocol{} is $(\epsilon, \delta)$-computationally differentially private (a.k.a.~CDP-ODB) if for every polynomial time distinguishing adversary \adversary{}, for every neighboring databases $\database \sim \database^\prime$, and for every query sequence $\fromNtoM{\query}{1}{m} \in \querySet^m$ where $m = \mathsf{poly}(\lambda)$,

			\begin{multline*}
				\probability{\adversary \left( 1^\lambda, \view{\protocol, \server}{\database, \fromNtoM{\query}{1}{m}} \right) = 1 } \leq \\
				\exp{\epsilon} \cdot \probability{\adversary \left( 1^\lambda, \view{\protocol ,\server}{\database^\prime, \fromNtoM{\query}{1}{m}} \right) = 1} + \delta + \negl \; ,
			\end{multline*}
			the probability is over the randomness of the distinguishing adversary \adversary{} and the protocol \protocol{}.
		\end{definition}

		\pause%

		Note:
		\begin{itemize}
			\item Entire view of the adversary is DP-protected
			\item Implies protection against communication volume and access pattern leakages
			\item Query sequence $\fromNtoM{\query}{1}{m} \in \querySet^m$ is fixed
			\item $\negl$ accounts for the computational (as opposed to theoretical) DP definition
		\end{itemize}

	\end{frame}

	\begin{frame}{On impossibility of adaptive queries}

		\begin{block}{Example}
			\justify%

			\begin{itemize}
				\item Suppose neighboring medical databases differ in one record with a rare diagnosis ``Alzheimer's disease''
				\item A medical professional queries the database
				\begin{itemize}
					\item
						for that diagnosis first (point query) \\
						\texttt{SELECT name FROM patients WHERE condition = 'ALZ'} % chktex 32

					\item
						if there is a record, she queries the senior patients next (range query) \\
						\texttt{SELECT name FROM patients WHERE age >= 65}

					\item
						otherwise she queries the general population,resulting in more records \\
						\texttt{SELECT name FROM patients}
				\end{itemize}
				\item Efficient system cannot return nearly the same number of records in both cases, thus, the adversary can distinguish
			\end{itemize}

		\end{block}

	\end{frame}

	\begin{frame}{Single-Threaded \epsolute{}}

		\centering
		\includegraphics[width=\textwidth]{dp-oram}

	\end{frame}

	\begin{frame}{Parallel \epsolute{}: the choice of separate vs shared \serverDS{}}

		\onslide<1->{
			\begin{itemize}
				\item Split \user{} and \server{} state into \oramsNumber{} ORAMs, run as separate machines
				\item Partition records randomly (by ID) into \oramsNumber{} partitions, generate \oramsNumber{} inverted indexes
				\item Choose a strategy on shared vs split \serverDS{}
			\end{itemize}
		}

		\begin{columns}[T]
			\begin{column}{0.5\textwidth}

				\onslide<2->{
					\begin{block}{No-$\gamma$ method: \serverDS{} per ORAM}

						\begin{itemize}[leftmargin=*]
							\item Composition of disjoint datasets: take max $\epsilon$
							\item Each ORAM replies with $(1 + \gamma) \frac{k_0}{\oramsNumber{}}$ records, where $k_0$ is a required number of records
							\item To bound probability to $\beta$, use $\gamma = \sqrt{ \frac{-3 \oramsNumber \log \beta}{ k_0 } }$
						\end{itemize}

					\end{block}
				}

			\end{column}

			\begin{column}{0.5\textwidth}

				\onslide<3->{
					\begin{block}{$\gamma$-method: shared \serverDS{}}

						\begin{itemize}[leftmargin=*]
							\item Same number of records per ORAM
							\item
								Use $\gamma$ as in no-$\gamma$ method, except
								\begin{itemize}
									\item $k_0 \gets k_0 + \frac{\log \domainSize}{\epsilon}$ for point queries
									\item $k_0 \gets k_0 + \frac{\log^{1.5} \domainSize}{\epsilon}$ for range queries
								\end{itemize}

						\end{itemize}

					\end{block}
				}

			\end{column}

		\end{columns}

	\end{frame}

	\begin{frame}{Parallel \epsolute{} diagram (with improvements)}

		\centering
		\includegraphics[scale=0.44]{three-layers}

	\end{frame}

	\begin{frame}{Experiments: against other mechanisms}

		\begin{figure}[h]
			\centering
			\includegraphics[width=\textwidth]{mechanism}
			\caption{
				\centering
				Different range-query mechanisms (log scale).
				Default setting: $10^6$ \SI{4}{\kibi\byte} uniformly-sampled records with the range $10^4$.
			}%
		\end{figure}

	\end{frame}

	\begin{frame}{Experiments: scalability}

		\begin{figure}[h]
			\centering
			\includegraphics[width=\columnwidth]{scalability}
			\caption{Scalability measurements for \protocolGamma{} and \protocolNoGamma{}}%
		\end{figure}

	\end{frame}
