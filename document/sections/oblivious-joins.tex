\section{Work-in-progress: \\ oblivious \texttt{JOIN}s}

	\begin{frame}[label={frame:oblivious-joins}]

		\frametitle{General idea}

		\begin{itemize}
			\item<1->
				Model: \alert{persistent}, query type: \alert{inner equi-\texttt{JOIN}}

			\item<2->
				Input: two tables $T_1$ and $T_2$, query: return a cross-product of $T_1$ and $T_2$ where $T_1.k = T_2.k$ \\
				\begin{small}
					We may also consider \texttt{SELECT JOIN}: \texttt{WHERE $T_1$.k = $T_2$.k AND $T_1$.a = 10}
				\end{small}

			\item<3->
				\alert{Challenge}: produce \texttt{JOIN} result hiding both access pattern and result size

			\item<4->
				\alert{Proposed solution}:
				\begin{itemize}
					\item use enclave (SGX) and oblivious primitives (sort, compaction)
					\item construct index over join keys, add DP noise to it
					\item partition the data by keys to fit a partition in the enclave
					\item consolidate sparse keys as an optimization
					\item do inner join within partition
					\item[] \hyperlink{frame:appendix:joins-detailed}{\beamerskipbutton{Detailed Algorithm}}
				\end{itemize}

		\end{itemize}

	\end{frame}

